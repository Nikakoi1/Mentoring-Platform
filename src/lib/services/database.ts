// Database service functions for Mentoring Platform
import { supabase } from '@/lib/supabase/client'
import type {
  Client,
  ClientVisit,
  ClientVisitEvaluation,
  CreateClientForm,
  CreateClientVisitEvaluationForm,
  CreateClientVisitForm,
  CreateGoalForm,
  CreateSessionEvaluationForm,
  CreateSessionForm,
  DatabaseFunction,
  Goal,
  Message,
  Mentee,
  MenteeProgress,
  Mentor,
  MentorStats,
  Pairing,
  PairingWithUsers,
  PlatformAnalytics,
  ProgressEntry,
  Resource,
  Session,
  SessionEvaluation,
  SessionWithUsers,
  SystemSettings,
  Translation,
  UpdateClientForm,
  UpdateClientVisitForm,
  User,
  UserWithRole,
  SystemSettingsRow,
  TranslationRow
} from '@/lib/types/database'

const DEFAULT_SYSTEM_SETTINGS: SystemSettings = {
  id: 'global',
  enableEmailNotifications: true,
  allowPublicRegistration: true,
  defaultUserRole: 'mentee',
  defaultLanguage: 'en'
}

const mapSystemSettingsRow = (row: SystemSettingsRow): SystemSettings => ({
  id: row.id,
  enableEmailNotifications: row.enable_email_notifications,
  allowPublicRegistration: row.allow_public_registration,
  defaultUserRole: row.default_user_role,
  defaultLanguage: row.default_language
})

const mapSystemSettingsPayload = (settings: Partial<SystemSettings>): Partial<SystemSettingsRow> => {
  const payload: Partial<SystemSettingsRow> = {}

  if (settings.enableEmailNotifications !== undefined) {
    payload.enable_email_notifications = settings.enableEmailNotifications
  }

  if (settings.allowPublicRegistration !== undefined) {
    payload.allow_public_registration = settings.allowPublicRegistration
  }

  if (settings.defaultUserRole !== undefined) {
    payload.default_user_role = settings.defaultUserRole
  }

  if (settings.defaultLanguage !== undefined) {
    payload.default_language = settings.defaultLanguage
  }

  return payload
}

type TranslationInput = {
  id?: string
  namespace: string
  key: string
  locale: string
  value: string
  autoGenerated?: boolean
}

const mapTranslationRow = (row: TranslationRow): Translation => ({
  id: row.id,
  namespace: row.namespace,
  key: row.translation_key,
  locale: row.locale,
  value: row.value,
  autoGenerated: row.auto_generated,
  updatedBy: row.updated_by ?? undefined,
  updatedAt: row.updated_at
})

const mapTranslationPayload = (translation: TranslationInput) => {
  const payload: Partial<TranslationRow> = {
    namespace: translation.namespace,
    translation_key: translation.key,
    locale: translation.locale,
    value: translation.value,
    auto_generated: translation.autoGenerated ?? false
  }

  if (translation.id) {
    payload.id = translation.id
  }

  return payload
}

const normalizeSupabaseError = (error: unknown): Error => {
  if (error instanceof Error) {
    return error
  }
  if (error && typeof error === 'object') {
    const maybeMessage = 'message' in error ? (error as { message?: string }).message : undefined
    const maybeDetails = 'details' in error ? (error as { details?: string }).details : undefined
    const text = [maybeMessage, maybeDetails].filter(Boolean).join(' - ')
    if (text) {
      return new Error(text)
    }
    try {
      return new Error(JSON.stringify(error))
    } catch {
      return new Error('Supabase request failed with an unknown error')
    }
  }
  return new Error(typeof error === 'string' ? error : 'Supabase request failed')
}

// User functions
export const getUserProfile = async (userId: string): Promise<DatabaseFunction<UserWithRole>> => {
  try {
    // First get the user
    const { data: user, error: userError } = await supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single()

    if (userError) {
      return { data: null, error: normalizeSupabaseError(userError) }
    }

    // Then get role-specific data based on user role
    let mentor = null
    let mentee = null

    if (user.role === 'mentor') {
      const { data: mentorData, error: mentorError } = await supabase
        .from('mentors')
        .select('*')
        .eq('id', userId)
        .single()
      if (mentorError) {
        return { data: null, error: normalizeSupabaseError(mentorError) }
      }
      mentor = mentorData
    }

    if (user.role === 'mentee') {
      const { data: menteeData, error: menteeError } = await supabase
        .from('mentees')
        .select('*')
        .eq('id', userId)
        .single()
      if (menteeError) {
        return { data: null, error: normalizeSupabaseError(menteeError) }
      }
      mentee = menteeData
    }

    const userWithRole = {
      ...user,
      mentor,
      mentee
    }

    return { data: userWithRole, error: null }
  } catch (error) {
    return { data: null, error: normalizeSupabaseError(error) }
  }
}

export const getUsersByIds = async (userIds: string[]): Promise<DatabaseFunction<User[]>> => {
  if (!userIds.length) {
    return { data: [], error: null }
  }

  const { data, error } = await supabase
    .from('users')
    .select('*')
    .in('id', userIds)

  return { data, error }
}

export const updateUserProfile = async (userId: string, updates: Partial<User>): Promise<DatabaseFunction<User>> => {
  const { data, error } = await supabase
    .from('users')
    .update(updates)
    .eq('id', userId)
    .select()
    .single()

  return { data, error }
}

export const createSessionEvaluation = async (
  evaluation: CreateSessionEvaluationForm
): Promise<DatabaseFunction<SessionEvaluation>> => {
  const { data, error } = await supabase
    .from('session_evaluations')
    .insert({
      ...evaluation,
      resource_ids: evaluation.resource_ids ?? []
    })
    .select('*')
    .single()

  return { data, error }
}

export const getSessionEvaluations = async (
  sessionId: string
): Promise<DatabaseFunction<SessionEvaluation[]>> => {
  const { data, error } = await supabase
    .from('session_evaluations')
    .select('*')
    .eq('session_id', sessionId)
    .order('created_at', { ascending: false })

  return { data, error }
}

export const updateClientVisit = async (
  visitId: string,
  updates: UpdateClientVisitForm
): Promise<DatabaseFunction<ClientVisit>> => {
  const { data, error } = await supabase
    .from('client_visits')
    .update(updates)
    .eq('id', visitId)
    .select('*')
    .single()

  return { data, error }
}

export const createClientVisitEvaluation = async (
  menteeId: string,
  visitId: string,
  evaluation: CreateClientVisitEvaluationForm
): Promise<DatabaseFunction<ClientVisitEvaluation>> => {
  const { data, error } = await supabase
    .from('client_visit_evaluations')
    .insert({
      visit_id: visitId,
      mentee_id: menteeId,
      rating: evaluation.rating,
      comment: evaluation.comment,
      resource_ids: evaluation.resource_ids ?? []
    })
    .select('*')
    .single()

  return { data, error }
}

export const getClientVisitEvaluations = async (
  visitId: string
): Promise<DatabaseFunction<ClientVisitEvaluation[]>> => {
  const { data, error } = await supabase
    .from('client_visit_evaluations')
    .select('*')
    .eq('visit_id', visitId)
    .order('created_at', { ascending: false })

  return { data, error }
}

// System settings functions
export const getSystemSettings = async (): Promise<DatabaseFunction<SystemSettings>> => {
  const { data, error } = await supabase
    .from('system_settings')
    .select('*')
    .eq('id', 'global')
    .maybeSingle<SystemSettingsRow>()

  if (error) {
    return { data: null, error }
  }

  if (!data) {
    return { data: DEFAULT_SYSTEM_SETTINGS, error: null }
  }

  return { data: mapSystemSettingsRow(data), error: null }
}

// Translation functions
export const getTranslationsByNamespaces = async (
  namespaces: string[],
  locale: string
): Promise<DatabaseFunction<Translation[]>> => {
  let query = supabase
    .from('translations')
    .select('*')
    .eq('locale', locale)

  if (namespaces.length) {
    query = query.in('namespace', namespaces)
  }

  const { data, error } = await query

  if (error) {
    return { data: null, error }
  }

  return { data: data?.map(mapTranslationRow) ?? [], error: null }
}

export const upsertTranslation = async (
  translation: TranslationInput
): Promise<DatabaseFunction<Translation>> => {
  const payload = mapTranslationPayload(translation)

  const { data, error } = await supabase
    .from('translations')
    .upsert(payload, { onConflict: 'namespace,translation_key,locale' })
    .select('*')
    .single<TranslationRow>()

  if (error) {
    return { data: null, error }
  }

  return { data: mapTranslationRow(data), error: null }
}

export const deleteTranslation = async (translationId: string) => {
  const { data, error } = await supabase
    .from('translations')
    .delete()
    .eq('id', translationId)
    .select('*')
    .maybeSingle<TranslationRow>()

  if (error) {
    return { data: null, error }
  }

  return { data: data ? mapTranslationRow(data) : null, error: null }
}

export const updateSystemSettings = async (
  updates: Partial<SystemSettings>
): Promise<DatabaseFunction<SystemSettings>> => {
  const payload = mapSystemSettingsPayload(updates)

  if (Object.keys(payload).length === 0) {
    return { data: null, error: new Error('No settings provided to update.') }
  }

  const { data, error } = await supabase
    .from('system_settings')
    .upsert({ id: 'global', ...payload }, { onConflict: 'id' })
    .select('*')
    .single<SystemSettingsRow>()

  if (error) {
    return { data: null, error }
  }

  return { data: mapSystemSettingsRow(data), error: null }
}

// Admin/Coordinator functions
export const getAllUsers = async (): Promise<DatabaseFunction<User[]>> => {
  const { data, error } = await supabase
    .from('users')
    .select('*')
    .order('created_at', { ascending: false })

  return { data, error }
}

export const getPlatformAnalytics = async (): Promise<DatabaseFunction<PlatformAnalytics>> => {
  const { data, error } = await supabase.rpc('get_platform_analytics')
  return { data, error }
}

// Enhanced analytics functions for detailed reports
export interface MentorAnalyticsDetail {
  mentor_id: string
  mentor_name: string
  mentor_email: string
  total_mentees: number
  active_mentees: number
  total_sessions: number
  completed_sessions: number
  planned_sessions: number
  average_evaluation: number | null
  total_goals: number
  achieved_goals: number
  mentees_details?: {
    mentee_id: string
    mentee_name: string
    mentee_email: string
    status: string
    total_sessions: number
    completed_sessions: number
    planned_sessions: number
    average_evaluation: number | null
    total_goals: number
    achieved_goals: number
  }[]
}

export interface SessionDetailRow {
  session_id: string
  title: string
  scheduled_time: string
  status: string
  evaluation_rating: number | null
  evaluation_comment: string | null
  goals_worked_on: string | null
  resources_shared: {
    id?: string
    title?: string
    resource_type?: string
  }[] | null
  session_type: string  // 'session' or 'client_visit'
}

export const getDetailedMentorAnalytics = async (
  startDate?: string,
  endDate?: string,
  mentorIds?: string[]
): Promise<DatabaseFunction<MentorAnalyticsDetail[]>> => {
  try {
    console.log('Calling get_detailed_mentor_analytics with:', { startDate, endDate, mentorIds })
    const { data, error } = await supabase.rpc('get_detailed_mentor_analytics', {
      start_date: startDate ?? null,
      end_date: endDate ?? null,
      mentor_ids: mentorIds && mentorIds.length > 0 ? mentorIds : null
    })
    
    if (error) {
      console.error('RPC error:', error)
    } else {
      console.log('RPC success, data length:', data?.length || 0)
    }
    
    return { data: (data ?? []) as MentorAnalyticsDetail[], error }
  } catch (err) {
    console.error('Exception in getDetailedMentorAnalytics:', err)
    const error = new Error(err instanceof Error ? err.message : 'Unknown error')
    return { data: null, error }
  }
}

export const getMenteeSessionDetails = async (
  menteeId: string,
  startDate?: string,
  endDate?: string
): Promise<DatabaseFunction<SessionDetailRow[]>> => {
  const { data, error } = await supabase.rpc('get_mentee_session_details', {
    mentee_id: menteeId,
    start_date: startDate,
    end_date: endDate
  })
  return { data: (data ?? []) as SessionDetailRow[], error }
}

export const getAllMentors = async (): Promise<DatabaseFunction<{ id: string; full_name?: string; email: string }[]>> => {
  const { data, error } = await supabase
    .from('users')
    .select('id, full_name, email')
    .eq('role', 'mentor')
    .order('full_name')

  return { data, error }
}

// Mentor functions
export const getMentorProfile = async (mentorId: string): Promise<DatabaseFunction<Mentor>> => {
  const { data, error } = await supabase
    .from('mentors')
    .select('*')
    .eq('id', mentorId)
    .single()

  return { data, error }
}

export const updateMentorProfile = async (mentorId: string, updates: Partial<Mentor>): Promise<DatabaseFunction<Mentor>> => {
  const { data, error } = await supabase
    .from('mentors')
    .update(updates)
    .eq('id', mentorId)
    .select()
    .single()

  return { data, error }
}

export const getMentorStats = async (mentorId: string): Promise<DatabaseFunction<MentorStats>> => {
  const { data, error } = await supabase
    .rpc('get_mentor_stats', { p_mentor_id: mentorId })

  return { data, error }
}

// Mentee functions
export const getMenteeProfile = async (menteeId: string): Promise<DatabaseFunction<Mentee>> => {
  const { data, error } = await supabase
    .from('mentees')
    .select('*')
    .eq('id', menteeId)
    .single()

  return { data, error }
}

export const updateMenteeProfile = async (menteeId: string, updates: Partial<Mentee>): Promise<DatabaseFunction<Mentee>> => {
  const { data, error } = await supabase
    .from('mentees')
    .update(updates)
    .eq('id', menteeId)
    .select()
    .single()

  return { data, error }
}

export const getMenteeProgress = async (menteeId: string): Promise<DatabaseFunction<MenteeProgress>> => {
  const { data, error } = await supabase
    .rpc('calculate_mentee_progress', { p_mentee_id: menteeId })

  return { data, error }
}

// Client functions (for mentees managing their clients)
export const getMenteeClients = async (menteeId: string): Promise<DatabaseFunction<Client[]>> => {
  const { data, error } = await supabase
    .from('clients')
    .select('*')
    .eq('mentee_id', menteeId)
    .order('created_at', { ascending: false })

  return { data, error }
}

export const createClient = async (menteeId: string, client: CreateClientForm): Promise<DatabaseFunction<Client>> => {
  const { data, error } = await supabase
    .from('clients')
    .insert({
      mentee_id: menteeId,
      display_name: client.display_name,
      address: client.address,
      services_provided: client.services_provided
    })
    .select()
    .single()

  return { data, error }
}

export const updateClient = async (clientId: string, updates: UpdateClientForm): Promise<DatabaseFunction<Client>> => {
  const { data, error } = await supabase
    .from('clients')
    .update(updates)
    .eq('id', clientId)
    .select()
    .single()

  return { data, error }
}

// Client visit scheduling (mentees visiting their clients)
export const createClientVisit = async (
  menteeId: string,
  visit: CreateClientVisitForm
): Promise<DatabaseFunction<ClientVisit>> => {
  const { data, error } = await supabase
    .from('client_visits')
    .insert({
      mentee_id: menteeId,
      client_id: visit.client_id,
      title: visit.title,
      description: visit.description,
      scheduled_at: visit.scheduled_at,
      duration_minutes: visit.duration_minutes || 60
    })
    .select()
    .single()

  return { data, error }
}

export const getClientVisits = async (menteeId: string): Promise<DatabaseFunction<ClientVisit[]>> => {
  const { data, error } = await supabase
    .from('client_visits')
    .select('*')
    .eq('mentee_id', menteeId)
    .order('scheduled_at', { ascending: true })

  return { data, error }
}

// Pairing functions
export const getUserPairings = async (userId: string): Promise<DatabaseFunction<PairingWithUsers[]>> => {
  const { data, error } = await supabase.rpc('get_user_pairings_with_details', { p_user_id: userId })
  
  // The RPC function returns a single JSONB object which is an array of pairings.
  // We can cast it directly to the expected type.
  return { data: data as PairingWithUsers[], error }
}

export const createPairing = async (pairing: Omit<Pairing, 'id' | 'created_at' | 'updated_at'>): Promise<DatabaseFunction<Pairing>> => {
  const { data, error } = await supabase
    .from('pairings')
    .insert(pairing)
    .select()
    .single()

  return { data, error }
}

export const updatePairing = async (pairingId: string, updates: Partial<Pairing>): Promise<DatabaseFunction<Pairing>> => {
  const { data, error } = await supabase
    .from('pairings')
    .update(updates)
    .eq('id', pairingId)
    .select()
    .single()

  return { data, error }
}

export const getAllPairings = async (): Promise<DatabaseFunction<PairingWithUsers[]>> => {
  const { data, error } = await supabase.rpc('get_all_pairings_with_details')

  return { data, error }
}

// Session functions
export const getUserSessions = async (userId: string): Promise<DatabaseFunction<SessionWithUsers[]>> => {
  const { data, error } = await supabase
    .from('sessions')
    .select(`
      *,
      mentor:mentor_id(*),
      mentee:mentee_id(*),
      pairing:pairing_id(*),
      goal:goal_id(*)
    `)
    .or(`mentor_id.eq.${userId},mentee_id.eq.${userId}`)
    .order('scheduled_at', { ascending: true })

  return { data, error }
}

export const getUpcomingSessions = async (userId: string): Promise<DatabaseFunction<Session[]>> => {
  const { data, error } = await supabase
    .from('sessions')
    .select('*')
    .or(`mentor_id.eq.${userId},mentee_id.eq.${userId}`)
    .eq('status', 'scheduled')
    .gte('scheduled_at', new Date().toISOString())
    .order('scheduled_at', { ascending: true })
    .limit(5)

  return { data, error }
}

type SessionInsertPayload = Partial<Session> & {
  mentee_ids?: string[]
}

export const createSession = async (session: CreateSessionForm): Promise<DatabaseFunction<Session>> => {
  // Handle backward compatibility and multi-mentee sessions
  const sessionPayload: SessionInsertPayload = {
    ...session,
    duration_minutes: session.duration_minutes || 60,
    session_type: session.session_type || 'regular',
    mode: session.mode || 'virtual'
  }

  // If mentee_ids is provided, use it for group sessions
  if (session.mentee_ids && session.mentee_ids.length > 0) {
    sessionPayload.mentee_ids = session.mentee_ids
    // For backward compatibility, set the first mentee as mentee_id
    sessionPayload.mentee_id = session.mentee_ids[0]
    // For group sessions, we might not have a single pairing_id
    if (!session.pairing_id && session.mentee_ids.length === 1) {
      // For single mentee, try to find the pairing
      const { data: pairings } = await supabase
        .from('pairings')
        .select('id')
        .eq('mentor_id', session.mentor_id)
        .eq('mentee_id', session.mentee_ids[0])
        .eq('status', 'active')
        .single()
      
      if (pairings) {
        sessionPayload.pairing_id = pairings.id
      }
    }
  } else if (session.mentee_id) {
    // Single mentee session (backward compatibility)
    sessionPayload.mentee_id = session.mentee_id
  }

  const { data, error } = await supabase
    .from('sessions')
    .insert(sessionPayload)
    .select()
    .single()

  return { data, error }
}

export const updateSession = async (sessionId: string, updates: Partial<Session>): Promise<DatabaseFunction<Session>> => {
  const { data, error } = await supabase
    .from('sessions')
    .update(updates)
    .eq('id', sessionId)
    .select()
    .single()

  return { data, error }
}

export const deleteSession = async (sessionId: string): Promise<DatabaseFunction<null>> => {
  const { error } = await supabase
    .from('sessions')
    .delete()
    .eq('id', sessionId)

  return { data: null, error }
}

// Goal functions
export const getPairingGoals = async (pairingId: string): Promise<DatabaseFunction<Goal[]>> => {
  const { data, error } = await supabase
    .from('goals')
    .select('*')
    .eq('pairing_id', pairingId)
    .order('created_at', { ascending: false })

  return { data, error }
}

export const getGoalsByPairingIds = async (pairingIds: string[]): Promise<DatabaseFunction<Goal[]>> => {
  if (!pairingIds.length) {
    return { data: [], error: null }
  }

  const { data, error } = await supabase
    .from('goals')
    .select('*')
    .in('pairing_id', pairingIds)
    .order('created_at', { ascending: false })

  return { data, error }
}

export const createGoal = async (goal: CreateGoalForm): Promise<DatabaseFunction<Goal>> => {
  const { data, error } = await supabase
    .from('goals')
    .insert({
      ...goal,
      priority: goal.priority || 'medium'
    })
    .select()
    .single()

  return { data, error }
}

export const updateGoal = async (goalId: string, updates: Partial<Goal>): Promise<DatabaseFunction<Goal>> => {
  const { data, error } = await supabase
    .from('goals')
    .update(updates)
    .eq('id', goalId)
    .select()
    .single()

  return { data, error }
}

export const deleteGoal = async (goalId: string): Promise<DatabaseFunction<Goal>> => {
  const { data, error } = await supabase
    .from('goals')
    .delete()
    .eq('id', goalId)
    .select()
    .single()

  return { data, error }
}

// Resource functions
export const getPairingResources = async (pairingId: string): Promise<DatabaseFunction<Resource[]>> => {
  const { data, error } = await supabase
    .from('resources')
    .select('*')
    .eq('pairing_id', pairingId)
    .order('created_at', { ascending: false })

  return { data, error }
}

export const uploadResource = async (resource: Omit<Resource, 'id' | 'created_at' | 'download_count'>): Promise<DatabaseFunction<Resource>> => {
  const { data, error } = await supabase
    .from('resources')
    .insert(resource)
    .select()
    .single()

  return { data, error }
}

// Progress functions
export const getPairingProgress = async (pairingId: string): Promise<DatabaseFunction<ProgressEntry[]>> => {
  const { data, error } = await supabase
    .from('progress_entries')
    .select('*')
    .eq('pairing_id', pairingId)
    .order('created_at', { ascending: false })

  return { data, error }
}

export const createProgressEntry = async (entry: Omit<ProgressEntry, 'id' | 'created_at'>): Promise<DatabaseFunction<ProgressEntry>> => {
  const { data, error } = await supabase
    .from('progress_entries')
    .insert(entry)
    .select()
    .single()

  return { data, error }
}

// Notification functions
export const getUserNotifications = async (userId: string): Promise<DatabaseFunction<Notification[]>> => {
  const { data, error } = await supabase
    .from('notifications')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false })
    .limit(20)

  return { data, error }
}

export const markNotificationAsRead = async (notificationId: string): Promise<DatabaseFunction<Notification>> => {
  const { data, error } = await supabase
    .from('notifications')
    .update({ read_at: new Date().toISOString() })
    .eq('id', notificationId)
    .select()
    .single()

  return { data, error }
}

// Message functions
export const getPairingMessages = async (pairingId: string): Promise<DatabaseFunction<Message[]>> => {
  const { data, error } = await supabase
    .from('messages')
    .select('*')
    .eq('pairing_id', pairingId)
    .order('created_at', { ascending: true })

  return { data, error }
}

export const sendMessage = async (message: Omit<Message, 'id' | 'created_at' | 'read_at'>): Promise<DatabaseFunction<Message>> => {
  const { data, error } = await supabase
    .from('messages')
    .insert(message)
    .select()
    .single()

  return { data, error }
}
