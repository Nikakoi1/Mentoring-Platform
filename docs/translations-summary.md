# Translation Module Summary

## Architecture Overview
- **LanguageProvider** (`src/contexts/LanguageContext.tsx`): wraps the app, exposes `locale`, `setLocale`, and `loading`. Persists locale to `localStorage` and syncs `<html lang>`. Defaults to English but hydrates from the stored preference.
- **LanguageSwitcher** (`src/components/common/LanguageSwitcher.tsx`): inline toggle (EN/KA) that calls `setLocale`. Disabled while context hydrates.
- **AppProviders** (`src/components/providers/AppProviders.tsx`): mounts `LanguageProvider`, `AuthProvider`, and renders `LanguageSwitcher` in the UI so every page gets locale context.

## Translation Retrieval
- **useTranslations hook** (`src/hooks/useTranslations.ts`):
  - Accepts `namespace` plus optional `defaults` map (English strings).
  - Reads active locale from `LanguageContext`.
  - Fetches namespace translations via `getTranslationsByNamespaces` (Supabase) and merges results with defaults.
  - Caches translations per locale and exposes `{ t(key, fallback), translations, loading, error, locale, refresh }`.

## Supabase Storage
- **Database service** (`src/lib/services/database.ts`):
  - `getTranslationsByNamespaces(namespaces, locale)` loads rows from the `translations` table.
  - `upsertTranslation` and `deleteTranslation` keep rows in sync. Rows map via `TranslationRow` from `src/lib/types/database.ts` (namespace, key, locale, value, autoGenerated, metadata).
- **System settings** also track `defaultLanguage` so new users inherit a locale if needed.

## Admin Interface
- **TranslationsManager** (`src/components/admin/TranslationsManager.tsx`) rendered at `/admin/translations` (`src/app/admin/translations/page.tsx`).
  - Provides filtering by namespace, locale switching, search, CRUD for translation keys, and status messaging.

## Adding / Updating Translations
1. **Use the hook**: In new components, call `useTranslations({ namespace: 'feature', defaults: { key: 'English text' } })`.
2. **Render strings**: Replace literal text with `t('key')` (provide fallbacks when helpful).
3. **Seed data**: Use the admin page (or Supabase directly via `upsertTranslation`) to add English + Georgian values for the namespace/keys.
4. **Verify**: Toggle the LanguageSwitcher to confirm the UI updates and cached translations refresh.
5. **Optional**: Adjust `defaultLanguage` in the system settings admin UI if you want newcomers to land on Georgian by default.

### When requesting new translations from AI assistant
Whenever you ask the assistant to translate a page/feature:

1. The assistant will draft the English source text and its Georgian equivalent (using automatic translation as a starting point).
2. The response will include a ready-to-run SQL `upsert` snippet targeting the `translations` table (suitable for Supabase SQL editor) so you can ingest the new keys quickly.
3. Review the Georgian output for nuance before executing the SQL in Supabase.
4. **Check the repo**: Every finalized SQL block must live in `database/` (e.g., `database/<feature>-translations.sql`) so the working copy always mirrors what is deployed.

### SQL output structure to remember
- Two separate `insert into public.translations` blocks:
  1. **English translations** – all rows for `locale = 'en'`, `auto_generated = false`.
  2. **Georgian translations** – matching rows for `locale = 'ka'`, usually with `auto_generated = true` until reviewed.
- Both blocks end with the same `on conflict (namespace, translation_key, locale) do update ...` clause.
- Keep identical ordering of keys in both sections so it is easy to verify each pair before running the SQL in Supabase.
- After running the SQL in Supabase, commit the same file so future contributors do not lose track of the canonical translation script.

This document summarizes the current bilingual setup (English/Georgian) so future pages can reuse the same pattern.
